#!/usr/bin/python
# Script to plot monitoring data from the AARTFAAC pipeline.
#  - Generate uncalibrated images and ACM visualization from a live (RT) GPU 
#	 visibility stream, or from text streams generated by pipeline instances.
#  - Parse GPU correlator stdout and generate plots of flagged data.
#  - Plot dipole frobenius norm timeseries, as generated by pipeline instances.
# Usage: afaacmon --gpucorr=ip:port --pipeline=ip:port ...
# pep/29Jan15

import sys;
import socket;
import optparse;
import time, datetime;
import ctypes;
import re;
try:
	import numpy;
	numpyFound = 1;
except ImportError:
	numpyFound = 0;

import math;
try:
	import scipy.io as sio;
	scipyFound = 1;
except ImportError:
	scipyFound = 0;

import os;
import struct;
try:
	import matplotlib.pylab as plt;
	import matplotlib.animation as animation;
	import matplotlib.dates as dates;
	matplotFound = 1;
except ImportError:
	matplotFound = 0;

try:
	import ephem; 
	ephemFound = 1;
except:
	ephemFound = 0;

try:
	import pyrap.images as msim;
	pyrapFound = 1;
except:
	pyrapFound = 0;

# Globals: Common to all data receivers
NRec2Buf  = 120; # Records in memory buffer for plotting.
Nelem     = 288; # The following remain constant for the 6-station A'FAAC    
Nbline    = Nelem*(Nelem+1)/2; 
Nchan     = 63;
Npol      = 4;
DoneRead  = 0;   # Bool to stop reading.
Stationid2Name = ['CS002', 'CS003', 'CS004', 'CS005', 'CS006', 'CS007']; 

class logHdlr:
	'Base class for all log handlers'

	""" Specify source of log info. as 'file:filename' or 'tcp:host:port'
	"""
	# Will store all known log parameter keys, defined in subclasses.
	_knownkeys = {}; 

	def __init__ (self, desc):
		self._streamtype = desc.split(':')[0];

		if self._streamtype == 'file':
			print '--> Operating on file ', desc.split(':')[1];
			try:
				self._fid = open (desc.split(':')[1], "rb");	
			except IOError:
				print 'File ', desc.split(':')[1], ' does not exist. Quitting.';
				
		elif self._streamtype == 'tcp':
			self._host = desc.split(':')[1];
			self._port = desc.split(':')[2]; 
			print '--> Operating on TCP socket.';
			self._fid = socket.socket (socket.AF_INET, socket.SOCK_STREAM);
			self._fid.bind( ('', self._port) );
			print '--> Binding on port ', self._port;
			self._fid.listen(1); # Blocking wait
			print '--> Found remote sender';
			self._clientconn,self._clientaddr = self._fid.accept ();
			print '--> Conn', self._clientconn, ' Addr: ', self._clientaddr; 
		else:
			print '### Unknown descriptor type ', self._streamtype, ' Quitting!';
			sys.exit();
		
		# Initialize counters
		self._recnum = 0;
		self._totrec = 0;

		# Read in the first line
		if (self._streamtype == 'file'):
			self._line = self._fid.readline();
		else:
			print 'TCP currently unsupported!';

	def __del__(self):
		print '<-- Clearing memory';
		print '<-- Total records read: %d, Final time: %f' % (self._totrec, self._knownkeys['TOBS']['VAL'][self._recnum,0]);
		if self._streamtype == 'file':
			self._fid.close();
		elif self._streamtype == 'tcp':
			self._clientconn.close();


#class msImgHandler:
#	'Class to handle images in casacore MeasurementSet format, as generated by the AARTFAAC imaging pipeline. Uses pyrap to access the MS, stores fits object in memory for display with aplpy. Note that multiple images are stored, upto the internally defined limit MAXMS. This allows operating on the images as a timeseries.'
#
#	# Public variables
#	# TODO
#	maxms = 100; # Adjust according to memory usage
#
#	# fnames : list of filenames
#	# def __init__ (self, fnames):
#
#	def openFiles (self,fnames):
#		assert (len (fnames) >= maxms);
#			
#
#	def readMS(self):
#		return -1;
#


class gpucorrTextLogHdlr(logHdlr):
	'Class to parse the stdout of the GPU correlator and extract out relevant parameters'
	_flagregexp = re.compile ('\[(\d+)s, (\d+)\], stats (\d+)-(\d+); flagged: ([-+]?(\d+(\.\d*)?))% \((\d+)\)');
	_timregexp = re.compile ('time: \[(\d+)s, (\d+)\], late: ([-+]?(\d+(\.\d*)?))s, exec: ([-+]?(\d+(\.\d*)?))');
	
	def __init__ (self, spec):
		logHdlr.__init__(self,spec);

		self._knownkeys = \
		 {'TOBS'       :{'UNIT':'Secs', 'VAL':numpy.empty( (NRec2Buf, 1) )}, 
		 'FLAGPERCENT':{'UNIT':'Percent', 'VAL':numpy.empty((NRec2Buf,Nelem))}, 
		 'EXECTIME'   :{'UNIT':'Secs', 'VAL': numpy.empty( (NRec2Buf, 1) )},
		 'LATETIME'   :{'UNIT':'Secs', 'VAL': numpy.empty( (NRec2Buf, 1) )}};


	def readRec (self):
		global DoneRead;
		recdone = 0;
		while not recdone:
			self._line = self._fid.readline();
			if not self._line: 
				print 'EOF reached. Last few records may be discarded.\n';
				DoneRead = 1;
				break;
			# print self._line;

			if 'stats' in self._line:
				m = self._flagregexp.match(self._line);
				if m:
					self._knownkeys['TOBS']['VAL'][self._recnum] = numpy.uint32(m.group(1));
					station = int(m.group(3)) / 48;
					flag = numpy.float16(m.group(5));
					# print 'Match: recnum: %d, station: %d, flag: %f ' % (self._recnum, station, flag);
					assert(station >= 0 and station <= 5)
					assert(flag >= 0 and flag <= 100)
					
					# if times[i] == 0:
					#    times[i] = time
					self._knownkeys['FLAGPERCENT']['VAL'][self._recnum,station] = flag;
					
					if station == 5:
						self._recnum += 1;
						self._totrec += 1;
						if (self._recnum >= NRec2Buf):
							self._recnum = 0;

			elif 'late:' in self._line:
				m = self._timregexp.match(self._line);
				if m:
					self._knownkeys['EXECTIME']['VAL'][self._recnum,0] = numpy.float(m.group(3));
					self._knownkeys['LATETIME']['VAL'][self._recnum,0] = numpy.float(m.group(6));
					# print 'Match: recnum: %d, late: %f, exec: %f ' % (self._recnum, numpy.float(m.group(3)), numpy.float(m.group(6)));

				# else:
				#     assert(times[i] == time)
		
class gpucorrVisHandler(logHdlr):
	'Class representing data from a single subband of visibilities, as generated by the GPU correlator'
	
	# Public variables, shared between all class instances.
	Sb2Port = {'sb0':5556, 'sb1':5556};
	Nsec2Rd = 10000; # -1 indicates read infinitely
	Hdrsize = 512;
	Recsize = Hdrsize + Nbline*Nchan*Npol*2*4; # 4 is for sizeof (float), 2 is for complex float.

	# Private variables
	# Create an array for every timeslice from all subbands
	# NOTE: These variables are local to each instance, eg. to allow
	# both GPU corr output and pipeline output to be seen.
	_tobs = numpy.zeros (NRec2Buf, 'd'); # Time of obs, as double
	_vis = numpy.zeros ([Nbline, Nchan, Npol, 2], 'f');
	_vis_int = numpy.zeros ([Nbline, Npol, 2], 'f');
	_acm = numpy.zeros ([Npol, Nelem*Nelem], dtype=complex);
	_acm_resh = numpy.zeros ([Npol, Nelem, Nelem], dtype=complex);
	_sel = numpy.nonzero(numpy.triu(numpy.ones([Nelem,Nelem])).flatten(1) == 1);
	_streamtype = 'file'; # Default

	""" desc. is a string descriptor of the source of data
		file:filename  = If gpu output is dumped to disk
		tcp:port       = if gpu output is streamed over network
	"""
	def __init__ (self, desc, sbnum):
		logHdlr.__init__(self, desc);
		self._sbnum = sbnum;


	""" Read a single record from a binary dump of GPU correlations, 
		either from file or tcp"""
	def readRec (self): # Can include number of records to read here TODO
		if self._streamtype == 'file':
			rec = self._fid.read (self.Recsize);
			if not rec: 
				print 'EOF reached. Last few records may be discarded.\n';
		 		Doneread = 1;

		elif self._streamtype == 'tcp':	
			bytes_recv = 0;
			self._chunks = [];
			ind = 0;
			while bytes_recv < self.Recsize:
				chunk = self._clientconn.recv (min ((self.Recsize - bytes_recv), 20480));
				# if chunk == b'':
				# 	raise RuntimeError ("Socket connection broken");
				self._chunks.append(chunk);
				bytes_recv = bytes_recv + len (chunk);
				ind = ind + 1;

			rec = ''.join(self._chunks);
		else:
			print 'Unknown streamtype: ', self_streamtype;
			
			# TOTO RAise an exception here.
		
		(magic, pad0, self._tobs, endTime) = struct.unpack ("<IIdd", rec[0:24]);
		print 'Start: %.2f, End: %.2f' % (self._tobs, endTime);
		self._fobs = 60000000; # TODO: Meta information needed here!
		self._vis = numpy.reshape (numpy.asarray (struct.unpack ("ff"*self.Nbline*self.Nchan*self.Npol, rec[512:])),[self.Nbline, self.Nchan, self.Npol, 2]);

		# Integrating over all channels in a subband;
		# self._vis_int = numpy.mean (self._vis, axis=1);
		self._vis_int = self._vis[:,32,:,:];

		# NOTE: Required to set acm to zero due to accumulation on _acm_resh,
		# which is a view (referenced object).
		self._acm[:,:]= 0;
		for ind in range (0, self.Npol):
			self._acm [ind,self._sel] = self._vis_int[:,ind,0] + 1j*self._vis_int[:,ind,1];

		# Make ACM hermitian symmetric
		self._acm_resh = numpy.reshape (self._acm, [self.Npol, self.Nelem, self.Nelem]);
		for ind in range (0, self.Npol):
			self._acm_resh [ind,:,:] = self._acm_resh[ind,:,:] + self._acm_resh[ind,:,:].conj().transpose();
	
		return self._acm_resh, self._tobs, self._fobs;

def mjdsec2Datetime(mjdsecarr):
	toffset = (datetime.datetime(1970,01,01) - 
		datetime.datetime (1858,11,17)).total_seconds();
	tmp = numpy.vectorize (datetime.datetime.utcfromtimestamp);
	return tmp(mjdsecarr - toffset);
		
		
class pipelineTextLogHdlr(logHdlr):
	' Class to receive the stream of text monitoring information generated by each pipeline into relevant datastructures for display.'
	_sb2port = {'sb0':4200, 'sb1':4201}; # Unused.

	def __init__ (self, desc):
		logHdlr.__init__(self, desc);

		# List of known keys 
		self._knownkeys = {'TOBS'            : numpy.empty ( (NRec2Buf, 1) ), 
						  'FOBS'            : numpy.empty ( (NRec2Buf, 1) ), 
						  'PERFORMANCE'     : numpy.empty ( (NRec2Buf, 1) ),
						  'FNORM'           : numpy.empty ( (NRec2Buf, 1) ), 
						  'FRINGE_AMPLITUDE': numpy.empty ( (NRec2Buf, 1) ),
						  'FRINGE_PHASE'    : numpy.empty ( (NRec2Buf, 1) ), 
						  'GAINS'           : numpy.empty ( (NRec2Buf ,288), 
															dtype=complex ),
						  'MAJORRESIDUES'   : numpy.empty ( (NRec2Buf, 1) ), 
						  'MINORRESIDUES'   : numpy.empty ( (NRec2Buf, 1) ),
						  'MAJORCYCLES'     : numpy.empty ( (NRec2Buf, 1) ), 
						  'SIMPLEXCYCLES'   : numpy.empty ( (NRec2Buf, 1) ), 
						  'FLAGGER'         : numpy.empty ( (NRec2Buf, Nelem))};


	def readRec (self):
		global DoneRead;

		if not self._line: 
			print 'EOF reached. Last few records may be discarded.\n';
			DoneRead = 1;

		# NOTE: The following assumes all data is read in a single go.
		tobs = float (self._line.split(' ')[2]); 
		fobs = 0;
		reftime = tobs;
		nkeysread = 1;
		rdflagger = 0;
		while (tobs == reftime and DoneRead == 0):
			units = self._line.split (' ');
			tmp = units[1].split('_');
			try:
				tmp[1] = float(tmp[1]);
				units[1] = tmp[0];
			except:
				pass;
				

			if (units[1].find ('MAJORCYCLES') >= 0):
				fobs = float(tmp[1]);
				self._knownkeys['MAJORCYCLES'][self._recnum,0] = float(units[3]);
				nkeysread += 1;

			elif (units[1].find ('FLAGGER') >= 0):
				if (rdflagger == 0):
					rdflagger = 1;
				self._knownkeys['FLAGGER'][self._recnum,int(tmp[1])] = float(units[3]);
				if (rdflagger == 0):
					nkeysread += 1;

			elif (units[1].find ('GAINS') >= 0):
				nkeysread += 1;
				pass;
				
			elif (units[1] in self._knownkeys):
				self._knownkeys[units[1]][self._recnum,0] = float(units[3]);
				nkeysread += 1;

			if (self._streamtype == 'file'):
				self._line = self._fid.readline(); # Read in a self._line.
			if not self._line: 
				print 'EOF reached. Last few records may be discarded.\n';
				DoneRead = 1;
			else:
				tobs = float (self._line.split(' ')[2]); 

		if nkeysread == len(self._knownkeys) - 2: # time and freq. missing
			self._knownkeys['TOBS'][self._recnum,0]  = tobs;
			self._knownkeys['FOBS'][self._recnum,0]  = fobs;
			self._recnum += 1;
			self._totrec += 1;
			if (self._recnum >= NRec2Buf):
				self._recnum = 0;
		else:
			print '--> Discarding partial record for time %.2f' % tobs;

	

#class imager:
#	'Class representing imaged data from a single subband of visibilities, all pols as generated by the GPU correlator'
#	# Public variables, shared between all class instances;
#	C = 2.9979245e8; # m/s
#
#	def __init__ (self, npix=512, mode='dft', fobs=60000000, sbnum='sb0', pol='xx'):
#		self._npix = npix;
#		self._pol = pol;
#		self._Npol = 1; # NOTE: Hardcoded!
#		self._skymap = numpy.asmatrix(numpy.zeros([self._npix, self._npix], 'f'));
#		self._tobs = -1; 
#		self._fobs = fobs;
#		self._mode = mode;
#		self._sbnum = sbnum;
#		self._meta = ctypes.create_string_buffer(subbandHandler.Hdrsize); # 512Byte file header.
#		print '--> Creating Imager in %s mode with npix %d for %s pol.' % (self._mode, self._npix, self._pol);
#
#		# Load antenna positions
#		mat_contents = sio.loadmat ('poslocal_outer.mat');
#		self._poslocal = numpy.asmatrix (mat_contents['poslocal']);
#
#		if self._mode == 'fft':
#			# Generate uv coordinates in local horizon coord. system, needed for
#			# imaging.
#			u1, v1 = numpy.meshgrid (numpy.asarray(self._poslocal[:,0]), numpy.asarray(self._poslocal[:,1]));
#			v2, u2 = numpy.meshgrid (numpy.asarray(self._poslocal[:,1]), numpy.asarray(self._poslocal[:,0]));
#			self._uloc = (u1 - u2).flatten(1);
#			self._vloc = (v1 - v2).flatten(1);
#
#			self._duv = 2.5;		# In units of meters, default, reassigned from freq. of obs. to
#									# image just the full Fov (-1<l<1)
#			self._Nuv = int(self._npix)/100 * 100; # size of gridded visibility matrix without padding.
#			self._dl = (self.C/(self._fobs * self._npix* self._duv)); # dimensionless, in dir. cos. units
#			self._lmax = self._dl * self._npix/ 2;
#			self._gridvis = numpy.zeros ([self._npix, self._npix], dtype=complex);
#			self._l = numpy.linspace (-self._lmax, self._lmax, self._npix);
#			self._m = numpy.linspace (-self._lmax, self._lmax, self._npix);
#
#
#		elif self._mode == 'dft':
#			self._l = numpy.asmatrix (numpy.linspace(-1, 1, self._npix));
#			self._dl = 2.0/self._npix;
#			self._m = self._l;
#
#			# Create imaging weights for DFT imaging
#		  	wavelength = self.C / fobs;
#			k = 2 * math.pi / wavelength;
#			self._wx = numpy.exp(-1j * k * self._poslocal[:,0] * self._l);
#			self._wy = numpy.exp(-1j * k * self._poslocal[:,1] * self._l);
#
#	def createImage (self, acm, tobs, fobs):
#		self._tobs = tobs;
#		if self._mode.lower() == 'dft':
#			self.createImageDFT (acm[0,:,:], tobs, fobs);
#		else:
#			self.createImageFFT (acm[0,:,:], tobs, fobs);
#
#	""" DFT based imager.
#		Arge: acm  = 4xNelemxNelem complex matrix
#			  tobs = time of observation in unix time
#	"""
#	def createImageDFT (self, acm, tobs, fobs):
#		self._tobs = tobs;
#		self._fobs = fobs;
#		# acm[0][:][:] = acm[0][:][:]+acm[0][:][:].conj().transpose();
#		self._skymap[:,:] = 0;
#		for lidx in range (0, self._npix):
#			for midx in range (0, self._npix):
#				weight = numpy.multiply(self._wx[:, lidx],self._wy[:, midx]);
#				self._skymap[lidx, midx] = (weight.conj().transpose() * acm[0][:][:] * weight).real;
#
#		return self._skymap;
#
#
#	def gridVis (self, acm):
#	
#		# For zero padding to desired (u,v)-size
#		N1 = numpy.floor((self._npix - self._Nuv) / 2);
#		self._gridvis[:,:] = 0;
#			
#		for idx in range (0, len(self._uloc)):
#			ampl = abs(acm[idx]);
#			if ampl == 0:
#				phasor = 0;
#			else:
#				phasor = acm[idx] / ampl;
#			uidx = self._uloc[idx] / self._duv + self._Nuv/2;
#			uidxl = math.floor(uidx);
#			uidxh = math.ceil(uidx);
#			dul = abs(uidx - uidxl);
#			duh = abs(uidx - uidxh);
#			sul = duh * ampl;
#			suh = dul * ampl;
#			
#			vidx = self._vloc[idx] / self._duv + self._Nuv / 2;
#			vidxl = math.floor(vidx);
#			vidxh = math.ceil(vidx);
#			dvl = abs(vidx - vidxl);
#			dvh = abs(vidx - vidxh);
#			sull = dvh * sul;
#			sulh = dvl * sul;
#			suhl = dvh * suh;
#			suhh = dvl * suh;
#			
#			self._gridvis[N1+uidxl, vidxl+N1] = self._gridvis[N1+uidxl, vidxl+N1] + sull * phasor;
#			self._gridvis[N1+uidxl, vidxh+N1] = self._gridvis[N1+uidxl, vidxh+N1] + sulh * phasor;
#			self._gridvis[N1+uidxh, vidxl+N1] = self._gridvis[N1+uidxh, vidxl+N1] + suhl * phasor;
#			self._gridvis[N1+uidxh, vidxh+N1] = self._gridvis[N1+uidxh, vidxh+N1] + suhh * phasor;
#		    
#	def createImageFFT (self, acm, tobs, fobs):
#		# Grid visibilities;
#		self.gridVis (acm.flatten(1));
#
#		# compute image
#		self._skymap[:,:] = numpy.fft.fftshift(numpy.fft.fft2(self._gridvis));
#		return self._skymap;
#
#	""" Function reads a file containing images written by writeImgToFile and 
#		generates a GIF out of them.
#	"""
#	def convertImgToGIF (self, fid):
#		return None; # TODO.
#
#	def writeMetaToFile(self, fid):
#		struct.pack_into ('<3s3sffff', self._meta, 0, self._mode, self._sbnum, float(self._npix), float(self._duv), float(self._dl), float(self._Npol));
#		numpy.array(self._meta).tofile(fid,sep="");		
#
#	def readMetaFromFile(self, fid):
#		rec = fid.read (subbandHandler.Hdrsize);
#		self._mode, self._sbnum, self._npix, self._duv, self._dl, self._Npol = struct.unpack_from('<3s3sffff',rec);
#		print '<-- Image Meta Information: '
#		print '<--   Mode: %s, sb: %s, npix: %f, dl: %f, Npol: %f' % (self._mode, self._sbnum, self._npix, self._dl, self._Npol);
#
#	def writeImgToFile (self, fid):
#		print 'Write: ', self._tobs, 'fobs: ', self._fobs;
#		numpy.array(numpy.float32 (self._tobs)).tofile(fid,sep="");
#		numpy.array(numpy.float32 (self._fobs)).tofile(fid,sep="");
#		# Readers can get shape information from the meta data block.
#		skymap1 = numpy.array(numpy.float32(abs(self._skymap.flatten(1))));   # skymap is a matrix type otherwise
#		skymap1.tofile(fid,sep="");# Written as float32
#
#	def readImgFromFile (self, fid):
#		# import pdb; pdb.set_trace();
#		t = numpy.fromfile (fid, dtype='float32',count=2);		
#		print 'tobs: %f, fobs: %f'% (t[0], t[1]);
#		img = numpy.fromfile (fid, dtype='float32',count=int(self._Npol*self._npix*self._npix));
#		return t[0], t[1], img;
#		
#
#class pltImage:
#	'Class representing a plot device on which images are shown'
#
#	def __init__ (self, im, location, fprefix='./',  wrpng=1, pltmoon=0):
#		self._wrpng = wrpng;
#		self._im = im;
#		self._nof_im = len(self._im); # Total number of images to display.
#		self._fprefix = fprefix;
#		self._pltmoon = pltmoon;
#		self._loc = location;
#
#		# Available locations
#		if self._loc.lower() == 'lofar':
#			self._obssite = ephem.Observer();
#			self._obssite.pressure = 0; # To prevent refraction corrections.
#			self._obssite.lon, self._obssite.lat = '6.869837540','52.915122495'; # CS002 on LOFAR
#		elif self._loc.lower() == 'dwingeloo':
#			self._obssite = ephem.Observer();
#			self._obssite.pressure = 0; # To prevent refraction corrections.
#			self._obssite.lon, self._obssite.lat = '6.396297','52.812204'; # Dwingeloo telescope
#		else:
#			print 'Unknown observatory site!'
#
#		if self._pltmoon == 1:
#			self._moon = ephem.Moon();
#			self._casa = ephem.readdb('Cas-A,f|J, 23:23:26.0, 58:48:00,99.00,2000');
#
#		if matplotFound ==0 & ephemFound == 0:
#			print 'Matplotlib or pyephem not found! PNG Images written to disk.'
#			self._wrpng = 1;
#		else:
#			self._imgplt = plt.imshow (abs(self._im[0]._skymap[:,:]), extent = [self._im[0]._l[0], self._im[0]._l[-1], self._im[0]._m[0], self._im[0]._m[-1]]);
#			plt.colorbar();
#			# plt.show();
#
#	def showImg (self):
#		if self._pltmoon == 1:
#			# Convert UTC unix time to datetime
#			self._obssite.date = datetime.datetime.fromtimestamp(self._im[0]._tobs); 
#
#			# Compute azi/alt
#			self._moon.compute(self._obssite);
#			self._casa.compute(self._obssite);
#
#
#			if self._moon.alt < 0:
#				print 'Moon below horizon at time ', self._obssite.date;
#			else:
#				# Compute l,m of moon's position, in units of array indices
#
#				moon_l = -(numpy.cos(self._moon.alt) * numpy.sin(self._moon.az));
#				moon_m =  (numpy.cos(self._moon.alt) * numpy.cos(self._moon.az)); 
#				# print 'l/m: %f, %f' % (moon_l, moon_m);
#				moon_l = moon_l/self._im[0]._dl + self._im[0]._npix/2;
#				moon_m = moon_m/self._im[0]._dl + self._im[0]._npix/2;
#				# print 'Moon: RA/dec = %f/%f, alt/az = %f/%f, lind/mind = %f/%f, dl=%f'% (self._moon.ra, self._moon.dec, self._moon.alt, self._moon.az, moon_l, moon_m, self._im._dl);
#
#			if self._casa.alt < 0:
#				print 'CasA below horizon at time ', self._obssite.date;
#			else:
#				casa_l = -(numpy.cos(self._casa.alt) * numpy.sin(self._casa.az));
#				casa_m =  (numpy.cos(self._casa.alt) * numpy.cos(self._casa.az)); 
#				# print 'l/m: %f, %f' % (casa_l, casa_m);
#				casa_l = casa_l/self._im[0]._dl + self._im[0]._npix/2;
#				casa_m = casa_m/self._im[0]._dl + self._im[0]._npix/2;
#				# print 'CasA: RA/dec = %f/%f, alt/az = %f/%f, lind/mind = %f/%f, dl=%f'% (self._casa.ra, self._casa.dec, self._casa.alt, self._casa.az, casa_l, casa_m, self._im._dl);
#
#
#			# Create a circle in the skymap centered at the location of the moon.
#			# blacking out a couple of pixels for now. 
#			if self._moon.alt > 0:
#				self._im[0]._skymap[moon_m-1:moon_m+1, moon_l-1:moon_l+1] = 5e10;	
#			self._im[0]._skymap[casa_m-1:casa_m+1, casa_l-1:casa_l+1] = 5e10;	
#			
#
#		self._imgplt.set_data (abs(self._im[0]._skymap[:,:]));
#
#		plt.title ('%s - %f' % (self._im[0]._pol, self._im[0]._tobs));
#		plt.draw();
#		plt.pause(0.001);
#		if self._wrpng == 1:
#			plt.savefig ('%s/%.0f_XX.png' % (self._fprefix,self._im[0]._tobs));


class pltLogs:
	' Class to display multiple plots resulting from an arbit. aggregation of logHdlr objects.'

	def __init__ (self, loghdlrs):
		
		

	def setupPltWin (self):

	def showlogplts (self):



""" 
   Main routine:
   -  Attach to the specified streams of data
   - 
"""
if __name__ == '__main__':
	if numpyFound == 0 | scipyFound == 0:
		print '### Numpy and/or scipy not found; unable to proceed.';
		sys.exit(-1);

	o = optparse.OptionParser()
	o.set_usage('vismon.py [options]')
	o.set_description(__doc__)
	
	o.add_option('-v', '--gpuvis', dest='gpuvissrc', default=0, help='Specify the source of GPU visibility stream, single subband. Uncalibrated images are created out of this.'); 
	
	o.add_option('-p', '--pipelog', dest='pipelogsrc', default=0, help='Specify the source of pipeline monitoring datastream.');

	o.add_option('-g', '--gpulog', dest='gpulogsrc', default=0, help='Specify the source of GPU logging datastream.');

	o.add_option('-i', '--calimg', dest='calimgsrc', default=0, help='Specify the source of calibrated Casacore images.');

	opts, args = o.parse_args(sys.argv[1:]);


	# Add all specified sources of log/status information.
	logsrc = [];	
	if opts.gpulogsrc != 0:
		logsrc.append (gpucorrTextLogHdlr (opts.gpulogsrc));

	if opts.pipelogsrc != 0:
		logsrc.append(pipelineTextLogHdlr (opts.pipelogsrc));

	if opts.gpuvissrc != 0:
		logsrc.append(gpucorrVisHdlr (opts.gpuvissrc));

	# if opts.calimgsrc != 0:
	# 	logsrc.append(calimgHdlr (opts.calimgsrc));

	# Initialize the plot display 
	# TODO

	while (DoneRead == 0):
		# Read in records from each log/status information source
		for src in logsrc:
			src.readRec();

		# Pass on to the plotter
"""
	
	print 'Total records read   : %d' % (pipehdlr._totrec);
	print 'Start/End time in buf: %f/%f' %(pipehdlr._knownkeys['TOBS'][0,0], pipehdlr._knownkeys['TOBS'][pipehdlr._recnum-1,0]);

	# Convert times to datetime
	# import pdb; pdb.set_trace();
	mpl_dates = dates.date2num (mjdsec2Datetime (pipehdlr._knownkeys['TOBS'][0:pipehdlr._recnum,0]));
	hfmt = dates.DateFormatter ('%m/%d %H:%M');

	fig = plt.figure ();
	ax = fig.add_subplot(111);
	plt.plot (mpl_dates, pipehdlr._knownkeys['FNORM'][0:pipehdlr._recnum,0], '-o');
	ax.xaxis.set_major_locator(dates.MinuteLocator());
	ax.xaxis.set_major_formatter(hfmt);
	# ax.set_ylim(bottom=0);
	plt.xticks(rotation='vertical');
	# plt.subplots_adjust(bottom=.3);
	plt.show();
"""


"""
        sb = subbandHandler (opts.fin, opts.sbnum);
        pols = ['xx', 'xy', 'yx', 'yy'];
        im = [];
        for pol in range (0,4):
                im.append (imager (opts.npix, opts.mode, 60000000, opts.sbnum, pols[pol]));

        irec = 0;

        # First record reading
        acm, tobs, fobs = sb.readRec();
        for pol in range (0,3):
                im[pol].createImage (acm, tobs, fobs);

        pltwin = pltImage (im, opts.loc, opts.fout, pltmoon=1);
"""

"""
        # Generate output file name based on first timeinstant
        print '--> Writing with prefix ', opts.fout;
        fname = '%s/%.0f_XX.img' % (opts.fout, tobs);
        print 'Filename:', fname;
        fid = open (fname, "wb");
        im.writeMetaToFile (fid); # Write out the meta information.
        im.writeImgToFile (fid);
"""

"""
        while irec < subbandHandler.Nsec2Rd:
                acm, tobs, fobs = sb.readRec();
                for pol in range (0,3):
                        im[pol].createImage (acm, tobs, fobs);
                pltwin.showImg();
                # im.writeImgToFile (fid);
                irec = irec + 1;
"""

